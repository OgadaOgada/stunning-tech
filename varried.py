# from os import error
# from types import BuiltinFunctionType


# mylist = [92,43,56,69,65]
# # print(len(mylist))
# ind = -1
# # right = -1

# def reversed(theList):
#     theList.reverse()
#     return theList

# def sorted(theList):
#     theList.sort()
#     return theList

# # print(mylist)
# # print("Sorted:",sorted(mylist))
# # print("Reversed after sorting:",reversed(sorted(mylist)))

# # # reversing by slicing the list
# # for i in mylist:
# #     newlist = mylist[::-1]
# # print("Generated by slicing",newlist)

# # newlist = mylist
# # print("New list", newlist)

# # # getting mid item(s)
# # # for i in mylist:
# # #     ind += 1

# # # if ind % 2 == 0:
# # #     midn = int(ind/2)
# # #     print(mylist[midn])
# # # else:
# # #     print("Double mid numbers")
# # #     frt = int((ind - 1)/2)
# # #     lst = int((ind + 1)/2)
# # #     print(str(mylist[frt])+" and "+str(mylist[lst]))

# # # print(mylist)
# # # mylist[2:3]=[]
# # # print(mylist)
# # class geeksforgeeks:
# #     def __init__(self):
# #         self.geek = "Geeks for geeks"
# #     def print_geeks(self):
# #         print(self.geek)

# # obj = geeksforgeeks()
# # obj.print_geeks()

# x = lambda a: a + 10
# print(x(5))
# pr = lambda a,b,c:(a*c)/b
# print(pr(4,5,10))


# class mycar:
#     def __init__(self,color,fuel,make,drive): #self can be anything but has to be the first
#         self.color = color
#         self.fuel = fuel
#         self.make = make
#         self.drive = drive
    
#     def myfunct(self): #self can be anything, not similar to the init 
#         print("My car is "+self.make+" and it's "+self.color)
#         print("My car is "+self.drive+" driven")
#         print("My car uses "+self.fuel)

# vits = mycar("blue","diesel","toyota","right")
# # print(vits.drive)
# vits.myfunct()
# vits.color = "grey"
# del vits.drive #to delete the drive parameter
# del vits #to delete the object
# # vits.myfunct()

# class person: #parent class
#     def __init__(self,fname,lname):
#         self.fname = fname
#         self.lname = lname
#     def funct(self):
#         print("\nFirst name ",self.fname,"\nSecond name ", self.lname)

# col = person("Collince","Ogada")
# col.funct()

# #child class
# class student(person):
#     def __init__(self, fname, lname,year):
#         super().__init__(fname, lname)
#         self.graduationyear = year
#     def welcome(self):
#         print("Welcome", self.fname, self.lname, "to the class of", self.graduationyear)
            

# s = student("Jane","Doe",2010)
# s.welcome()

# condition = False
# x =1 if condition else 0 #ternary operator in python
# print("Value of x is ",x)

# num1 = 2389282323 #for a big number like this, you can add underscore seperator as below
# num2 = 394_867_219
# total = num1 + num2
# print(f'{total:,}') #formatting output to have commas
# print()

# mylist = ["Collince","Ogada","Otieno","Babygirl","Test","Nairobi"]
# mylist2 = [10,20,30]
# mylist3 = ["Present","Absent","Ppresent","Present","Present","Absent"]
# # for index, name in enumerate(mylist):
# for index, name in enumerate(mylist,start=1):
#     print(index,name)
# print()

# #by default, zip will stop at the shortest list available
# #if you want zip to go to the longest list, use ziplongest from itertools module

# #looping all three list
# for name, num , pre in zip(mylist,mylist2,mylist3):
#     # print(f'{num} belongs to {name} :-{pre}')
#     print('{} belongs to {}:- {}'.format(num,name,pre))
# print()

# #using one variable
# for value in zip(mylist2,mylist,mylist3):
#     # print(f'{num} belongs to {name} :-{pre}')
#     print('{}'.format(value))
# print()
# #underscore used to ignore
# # a,b,*c = (1,2,3,4,5,6,7) #the asterisk makes c to take everything that remains after a, b has been assigned
# # a,b,*_ = (1,2,3,4,5,6,7) #asterisk and underscore ignores everything else after a,b has been aassigned
# a,b,*c,d = (1,2,3,4,5,6,7) #sets a,b to first and second, then everything else except the last one to c, then the last one to d
# a,b,*_,d = (1,2,3,4,5,6,7,9) #ignore the middle values and assign the last one to d
# print("a",a)
# print("b",b)
# # print("c",c)
# print("d",d)

# class person():
#      pass
# guy = person()
# # guy.first = "Collince"
# # guy.last = "Ogada"
# firstkey = "first"
# firstval = "Unpacking"
# setattr(guy,firstkey,firstval)

# first = getattr(guy,firstkey)
# print(first)
# # print(guy.Good)
# print()

# person_info = {'first':'Collince','last':"Otieno"}

# for key, value in person_info.items():
#     setattr(guy,key,value)
# print(guy.first)
# print(guy.last)
# print()

# for key in person_info.keys():
#     print(getattr(guy,key))

# from getpass import getpass

# username = input("Username: ")
# password = getpass("Password: ")

# print("Logging in ....")

# import smtpd
# from datetime import datetime
# # help (smtpd)
# print(dir(datetime))
# print(datetime.today())

# myDict = {"ns":"green","ew":"red"}
# def switchLights(intersection):
#     for key in intersection.keys():
#         if intersection[key] == "green":
#             intersection[key] = "yellow"

#         if intersection[key] == "yellow":
#             intersection[key] = "red"

#         if intersection[key] == "red":
#             # intersection[key] = "green"
#             intersection[key] = "red" #changed so that assert doen't throw errors
    
#     # this conditin always hold true, if not then there's a bug
#     assert "red" in intersection.values(), "Neither light is red!"+str(intersection)

# switchLights(myDict)

# import logging
# #to log to a file, add filename=nmaeoffile.txt to basic config as below
# # logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")
# # #without loggint o text file
# logging.basicConfig(filename="myProgramLog.txt", level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")
# # above passed a relative path name, log file save in the current working dir
# #logging to text file works when logging isn't disabled, nothing prints on screen but are saved on text file

# # to disable logging, you just call logging.disable
# logging.disable(logging.CRITICAL)

# # levels of logging
#     # debug(lowest)
#     # info - 
#     # warning - something could go wrong
#     # error - something has gone wrong
#     # critical(highest) - something has gone wrong and program needs to stop
# logging.debug("Start of program")

# def facto(num):
#     logging.debug("Start of factorial(%s)" %(num)) 
#     total = 1
#     # for i in range(num+1): #changed this to 1 for correction
#     for i in range(1,num+1):
#         total *= i
#         logging.debug("i is %s, total is %s" %(i,total))
#     logging.debug("Return value is %s" %(total))
#     return total
# print("Factorial of 5",facto(5))

# logging.debug("End of program")

# import random
# import time
# heads = 0
# for i in range(1,1001):
#     myrand = random.randint(0,1)
#     if  myrand == 1:
#         heads = heads + 1
#     if i == 500:
#         # print("Halfway done, {} heads so far".format(heads))
#         # print("Halfway done, "+str(heads)+" heads so far")
#         print("Halfway done, %s heads so far"%(heads))
#         time.sleep(1)
# print("Heads came up "+str(heads)+" times")

import webbrowser, sys

# webbrowser.open("google.com")
sys.argv #a list together with the arguments passed

if len(sys.argv) >1 :
    " ".join(sys.argv[1:]) #starts at index 1 and joins the list to the end

